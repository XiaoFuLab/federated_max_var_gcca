function [ Q,G ,obj,St] = LargeGCCA_new( X,K, varargin )

%MaxIt,G,Q,Li,EXTRA,WZW,norm_vec,vec_ind


if (nargin-length(varargin)) ~= 2
    error('Wrong number of required parameters');
end

%--------------------------------------------------------------
% Set the defaults for the optional parameters
%--------------------------------------------------------------


[L,M]=size(X{1});
MaxIt = 1000;
EXTRA = 0;

T = 2;
%--------------------------------------------------------------
% Read the optional parameters
%--------------------------------------------------------------
if (rem(length(varargin),2)==1)
    error('Optional parameters should always go by pairs');
else
    for i=1:2:(length(varargin)-1)
        switch upper(varargin{i})
            case 'R'  % regularization parameter
                r = varargin{i+1};
            case 'MAXIT'
                MaxIt = varargin{i+1};
            case 'G_INI'
                G = varargin{i+1};
            case 'Q_INI'
                Q = varargin{i+1};
            case 'LI'
                Li = varargin{i+1};
            case 'NORM_VEC' % vector for weighting/ normalization
                norm_vec = varargin{i+1};
            case 'VEC_IND'
                vec_ind = varargin{i+1}; % vec_ind(:,i) indicates which row is missing in Xi
            case 'ALGO_TYPE'
                algo_type = varargin{i+1}; %'plain','weight','weight_center','weight_center_fs' (fs: feature-selective)
            case 'INNER_IT'
                T =  varargin{i+1};
            case 'EXTRA'
                EXTRA =  varargin{i+1};
            case 'UM'
                Um =  varargin{i+1}; % for measuring error
            otherwise
                % Hmmm, something wrong with the parameter string
                error(['Unrecognized option: ''' varargin{i} '''']);
        end;
    end;
end






%%


[~,I]=size(X);

[L,M]=size(X{1});

obj_temp = 0;
for i=1:I
    obj_temp =(1/2)*sum(sum(((1/sqrt(L))*X{i}*Q{i}-G).^2))+ (r/2)*sum(sum(Q{i}.^2)) + obj_temp;
end
obj_0=sum(obj_temp);
dist_0 = norm(Um'*G,2);
switch algo_type
    case 'plain'
        
        for i=1:I
%             Li{i} = norm(X{i}'*X{i}+r*eye(M),'fro');
            Li{i}=Li{i}+r;
        end
        
        tk=1;
        Q_old = Q;
        Q_tilde = cell(1,I);
        for it=1:MaxIt
            
             
            
            disp(['at iteration ',num2str(it)])
            
            %
            %             if it>1
            %                 tk_plus_one = (1+sqrt(1+4*tk^2))/2;
            %             end
            for i=1:I
                
                if EXTRA ==1
                    Q_old{i} = Q{i};
                    tk = 1;
                    for inner_it=1:T
                        if inner_it >1 
                            tk_plus_one = (1+sqrt(1+4*tk^2))/2;
                            Q_tilde{i} = Q{i} + (tk-1)/tk_plus_one*(Q{i}-Q_old{i});
                            Q_old{i} = Q{i};
                            Q{i} = Q_tilde{i}-(1/Li{i})*((1/L)*X{i}'*(X{i}*Q_tilde{i})+r*Q_tilde{i}-(1/sqrt(L))*X{i}'*G);
                            tk = tk_plus_one;
                        else
                            Q{i}=Q{i}-(1/Li{i})*((1/L)*X{i}'*(X{i}*Q{i})+r*Q{i}-(1/sqrt(L))*X{i}'*G);
                        end 
                        
                        if inner_it>1&&sqrt(sum(sum((Q{i}-Q_old{i}).^2)))<1e-6;
                            break;
                        end
                        
                    end
                else
                    for inner_it=1:T
                        Q{i}=Q{i}-(1/Li{i})*((1/L)*X{i}'*(X{i}*Q{i})+r*Q{i}-(1/sqrt(L))*X{i}'*G);
                    end
                    %                 end
                end
           
            end
            M_temp = zeros(L,K);
            for i=1:I
                XQ{i}=X{i}*Q{i};
                M_temp = M_temp + XQ{i};
            end
            
            
            % SVD version - global optimality guaranteed
            
            [Ut,St,Vt]=svd(M_temp/I,0);
            G = Ut(:,1:K)*Vt';
            
            
            obj_temp = 0;
            for i=1:I
                obj_temp =(1/2)*sum(sum(((1/sqrt(L))*X{i}*Q{i}-G).^2))+ (r/2)*sum(sum(Q{i}.^2)) + obj_temp;
            end
            obj(it)=sum(obj_temp);
            dist(it) = norm(Um'*G,2);
%             if it>1&&abs(obj(it)-obj(it-1))<1e-12
%                 break;
%             end
%             
            
            
            
        end
        %%
    case 'weight'
        
        for i=1:I
            Gi{i} = bsxfun(@times,G,vec_ind(:,i));
            Li{i}=Li{i}+r;
        end
        
        sqrt_norm_vec=sqrt(norm_vec);
        
        
        tk=1;
        Q_old = Q;
        Q_tilde = cell(1,I);
        for it=1:MaxIt
            
            
            disp(['at iteration ',num2str(it)])
            
            tic
            if it>1
                tk_plus_one = (1+sqrt(1+4*tk^2))/2;
            end
            for i=1:I
                
                
                if EXTRA ==1
                    if it>1
                        
                        Q_tilde{i} = Q{i} + (tk-1)/tk_plus_one*(Q{i}-Q_old{i});
                        
                        Q_old{i}=Q{i};
                        Q{i} = Q_tilde{i}-(1/Li{i})*(X{i}'*(X{i}*Q_tilde{i})+r*Q_tilde{i}-X{i}'*Gi{i} );
                    else
                        Q{i}=Q{i}-(1/Li{i})*(X{i}'*(X{i}*Q{i})+r*Q{i}-X{i}'*Gi{i} );
                    end
                else
                    Q{i}=Q{i}-(1/Li{i})*((1/L)*X{i}'*(X{i}*Q{i})+r*Q{i}-(1/sqrt(L))*X{i}'*Gi{i} );
                end
            end
            if it>1
                tk = tk_plus_one;
            end
            M_temp = zeros(L,K);
            for i=1:I
                XQ{i}=X{i}*Q{i};
                M_temp = M_temp + XQ{i};
            end
            
            
            % SVD version - global optimality guaranteed
            M_temp = bsxfun(@rdivide,M_temp,sqrt_norm_vec);
            
            [Ut,St,Vt]=svd(M_temp/I,0);
            G = Ut(:,1:K)*Vt';
            
            
            
            obj_temp = 0;
            G = bsxfun(@rdivide,G,sqrt_norm_vec);
            for i=1:I
                Gi{i}  = bsxfun(@times,G,vec_ind(:,i));
                obj_temp = sum(sum(((1/sqrt(L))*XQ{i} - Gi{i}).^2))+r*sum(sum(Q{i}.^2));
            end
            obj(it)=sum(obj_temp);
            
            disp(['costvalue is ',num2str(obj(it))])
            
            %    if mod(it,10)==0 % save the result every 50 iterations maybe
            %        filename =  ['iteration_noCentering_',num2str(it+2000)];
            %        save(filename,'Q','G','obj')
            %    end
            
            one_it_time = toc
            
        end
        
        %%
    case 'weight_center'
        r = 0;
        for i=1:I
            Gi{i} = bsxfun(@times,G,vec_ind(:,i));
            Ci_G{i} = Gi{i}-ones(L,1)*(1/nnz(vec_ind(:,i)))*sum(Gi{i}); % Ci'*Wi*G in the paper
            Li{i}=Li{i}+r;
        end
        
        sqrt_norm_vec=sqrt(norm_vec);
        
        
        tk=1;
        Q_old = Q;
        Q_tilde = cell(1,I);
        for it=1:MaxIt
            
            
            disp(['at iteration ',num2str(it)])
            
            tic
            if it>1
                tk_plus_one = (1+sqrt(1+4*tk^2))/2;
            end
            for i=1:I
                if EXTRA ==1
                    if it>1
                        Q_tilde{i} = Q{i} + (tk-1)/tk_plus_one*(Q{i}-Q_old{i});
                        Q_old{i}=Q{i};
                        XQ{i} = X{i}*Q_tilde{i};
                        CXQ{i}= XQ{i} - ones(L,1)*(1/nnz(vec_ind(:,i)))*sum(XQ{i});
                        WCXQ{i} = bsxfun(@times,CXQ{i},vec_ind(:,i));
                        CWCXQ{i}= WCXQ{i} - ones(L,1)*(1/nnz(vec_ind(:,i)))*sum(WCXQ{i});
                        Q{i}=Q_tilde{i}-(1/Li{i})*(X{i}'*CWCXQ{i}-X{i}'*Ci_G{i}+r*Q_tilde{i});
                        
                    else
                        XQ{i} = X{i}*Q{i};
                        CXQ{i}= XQ{i} - ones(L,1)*(1/nnz(vec_ind(:,i)))*sum(XQ{i});
                        WCXQ{i} = bsxfun(@times,CXQ{i},vec_ind(:,i));
                        CWCXQ{i}= WCXQ{i} - ones(L,1)*(1/nnz(vec_ind(:,i)))*sum(WCXQ{i});
                        Q{i}=Q{i}-(1/Li{i})*(X{i}'*CWCXQ{i}-X{i}'*Ci_G{i}+r*Q{i});
                    end
                else
                    XQ{i} = X{i}*Q{i};
                    CXQ{i}= XQ{i} - ones(L,1)*(1/nnz(vec_ind(:,i)))*sum(XQ{i});
                    WCXQ{i} = bsxfun(@times,CXQ{i},vec_ind(:,i));
                    CWCXQ{i}= WCXQ{i} - ones(L,1)*(1/nnz(vec_ind(:,i)))*sum(WCXQ{i});
                    Q{i}=Q{i}-(1/Li{i})*(X{i}'*CWCXQ{i}-X{i}'*Ci_G{i}+r*Q{i});
                end
            end
            if it>1
                tk = tk_plus_one;
            end
            M_temp = zeros(L,K);
            for i=1:I
                XQ{i}=X{i}*Q{i};
                CXQ{i}= XQ{i} - ones(L,1)*(1/nnz(vec_ind(:,i)))*sum(XQ{i});
                WCXQ{i} = bsxfun(@times,CXQ{i},vec_ind(:,i));
                M_temp = M_temp + WCXQ{i};
            end
            
            
            % SVD version - global optimality guaranteed
            M_temp = bsxfun(@rdivide,M_temp,sqrt_norm_vec);
            
            [Ut,St,Vt]=svd(M_temp/I,0);
            G = Ut(:,1:K)*Vt';
            
            
            
            obj_temp = 0;Q_norm = 0;
            G = bsxfun(@rdivide,G,sqrt_norm_vec);
            for i=1:I
                Gi{i} = bsxfun(@times,G,vec_ind(:,i));
                Ci_G{i} = Gi{i}-ones(L,1)*(1/nnz(vec_ind(:,i)))*sum(Gi{i});
                obj_temp = sum(sum((WCXQ{i} - Gi{i}).^2));
                Q_norm = Q_norm + sum(sum(Q{i}.^2));
            end
            obj(it)=sum(obj_temp)+r*sum(Q_norm);
            fit(it)=sum(obj_temp);
            
            disp(['costvalue is ',num2str(obj(it)),' fitvalue is ',num2str(fit(it))])
            
            %    if mod(it,10)==0 % save the result every 50 iterations maybe
            %        filename =  ['iteration_center_',num2str(it)];
            %        save(filename,'Q','G','obj')
            %    end
            
            one_it_time = toc
            
        end
        %%
    case 'weight_center_fs'
        [~,I]=size(X);
        
        [L,M]=size(X{1});
        
        [Lprime,K]=size(Q{1});
        lambda = r*ones(1,Lprime);
        
        for i=1:I
            Gi{i} = bsxfun(@times,G,vec_ind(:,i));
            Ci_G{i} = Gi{i}-ones(L,1)*(1/nnz(vec_ind(:,i)))*sum(Gi{i}); % Ci'*Wi*G in the paper
            Li{i}=Li{i}+r;
        end
        
        sqrt_norm_vec=sqrt(norm_vec);
        
        
        tk=1;
        Q_old = Q;
        Q_tilde = cell(1,I);
        for it=1:MaxIt
            
            tic
            if it>1
                tk_plus_one = (1+sqrt(1+4*tk^2))/2;
            end
            for i=1:I
                if EXTRA ==1
                    if it>1
                        Q_tilde{i} = Q{i} + (tk-1)/tk_plus_one*(Q{i}-Q_old{i});
                        Q_old{i}=Q{i};
                        
                        
                        
                        XQ{i} = X{i}*Q_tilde{i};
                        CXQ{i}= XQ{i} - ones(L,1)*(1/nnz(vec_ind(:,i)))*sum(XQ{i});
                        WCXQ{i} = bsxfun(@times,CXQ{i},vec_ind(:,i));
                        CWCXQ{i}= WCXQ{i} - ones(L,1)*(1/nnz(vec_ind(:,i)))*sum(WCXQ{i});
                        
                        %                 Q{i} = Q_tilde{i}-(1/Li{i})*(X{i}'*(X{i}*Q_tilde{i})+r*Q_tilde{i}-X{i}'*Ci_G{i});
                        Q{i}=Q_tilde{i}-(1/Li{i})*(X{i}'*CWCXQ{i}-X{i}'*Ci_G{i});
                        Q{i}  = (shrinkL1Lp(Q{i},(1/Li{i})*lambda,2));
                    else
                        XQ{i} = X{i}*Q{i};
                        CXQ{i}= XQ{i} - ones(L,1)*(1/nnz(vec_ind(:,i)))*sum(XQ{i});
                        WCXQ{i} = bsxfun(@times,CXQ{i},vec_ind(:,i));
                        CWCXQ{i}= WCXQ{i} - ones(L,1)*(1/nnz(vec_ind(:,i)))*sum(WCXQ{i});
                        Q{i}=Q{i}-(1/Li{i})*(X{i}'*CWCXQ{i}-X{i}'*Ci_G{i});
                        Q{i}  = (shrinkL1Lp(Q{i},(1/Li{i})*lambda,2));
                    end
                else
                    XQ{i} = X{i}*Q{i};
                    CXQ{i}= XQ{i} - ones(L,1)*(1/nnz(vec_ind(:,i)))*sum(XQ{i});
                    WCXQ{i} = bsxfun(@times,CXQ{i},vec_ind(:,i));
                    CWCXQ{i}= WCXQ{i} - ones(L,1)*(1/nnz(vec_ind(:,i)))*sum(WCXQ{i});
                    Q{i}=   Q{i}-(1/Li{i})*(X{i}'*CWCXQ{i}-X{i}'*Ci_G{i});
                    Q{i}  = (shrinkL1Lp(Q{i},(1/Li{i})*lambda,2));
                end
            end
            if it>1
                tk = tk_plus_one;
            end
            M_temp = zeros(L,K);
            for i=1:I
                XQ{i}=X{i}*Q{i};
                CXQ{i}= XQ{i} - ones(L,1)*(1/nnz(vec_ind(:,i)))*sum(XQ{i});
                WCXQ{i} = bsxfun(@times,CXQ{i},vec_ind(:,i));
                M_temp = M_temp + WCXQ{i};
            end
            
            
            % SVD version - global optimality guaranteed
            M_temp = bsxfun(@rdivide,M_temp,sqrt_norm_vec);
            
            [Ut,St,Vt]=svd(M_temp/I,0);
            G = Ut(:,1:K)*Vt';
            
            
            
            obj_temp = 0;
            G = bsxfun(@rdivide,G,sqrt_norm_vec);
            for i=1:I
                Gi{i} = bsxfun(@times,G,vec_ind(:,i));
                Ci_G{i} = Gi{i}-ones(L,1)*(1/nnz(vec_ind(:,i)))*sum(Gi{i});
                obj_temp = (1/2)*sum(sum((WCXQ{i} - Gi{i}).^2))+lambda(1)*sum(sqrt(sum(Q{i}.^2,2)));
            end
            obj(it)=sum(obj_temp);
            
            disp(['costvalue is ',num2str(obj(it))])
            
            Sparsity = nnz(sum(Q{1},2))/(size(Q{1},1));
            
            disp(['sparsity of Q1 is ',num2str(Sparsity)]);
            %    if mod(it,10)==0 % save the result every 50 iterations maybe
            %        filename =  ['iteration_feature_',num2str(r),'_',num2str(it)];
            %        save(filename,'Q','G','obj')
            %    end
            
            
        end
end

obj = [obj_0,obj];
end

function C2 = shrinkL1Lp(C1,lambda,p)

% This function solves the shrinkage/thresholding problem for different
% norms p in {1, 2, inf}
%--------------------------------------------------------------------------
% Copyright @ Ehsan Elhamifar, 2014
%--------------------------------------------------------------------------

C2 = [];
if ~isempty(lambda)
    [D,N] = size(C1);
    if (p == 1)
        C2 = max(abs(C1)-repmat(lambda,N,1),0) .* sign(C1);
    elseif (p == 2)
        r = zeros(D,1);
        for j = 1:D
            r(j) = max(norm(C1(j,:))-lambda(j),0);
        end
        C2 = repmat(r./(r+lambda'),1,N) .* C1;
    elseif(p == inf)
        C2 = zeros(D,N);
        for j = 1:D
            C2(j,:) =      L2_Linf_shrink(C1(j,:)',lambda(j))';
            %               if 2*lambda(j)<1e-10
            %                   C2(j,:)= C1(j,:);
            %               else
            %               C2(j,:) = (C1(j,:)' - ProjectOntoL1Ball(C1(j,:)', 2*lambda(j))).';
            %               end
        end
    end
end
end

function x = L2_Linf_shrink(y,t)
% This function minimizes
%     0.5*||b*x-y||_2^2 + t*||x||_inf
% where b is a scalar.  Note that it suffices
% to consider the minimization
%     0.5*||x-y||_2^2 + t/b*||x||_inf
% and so we will assume that the value of b has
% been absorbed into t (= tau).
% The minimization proceeds by initializing
% x with y.  Let z be y re-ordered so that
% the abs(z) is in descending order.  Then
% first solve
%     min_{b>=abs(z2)} 0.5*(b-abs(z1))^2 + t*b
% if b* = abs(z2), then repeat with first and
% second largest z values;
%     min_{b>=abs(z3)} 0.5*(b-abs(z1))^2+0.5*(b-abs(z2))^2 + t*b
% which by expanding the square is equivalent to
%     min_{b>=abs(z3)} 0.5*(b-mean(abs(z1),abs(z2)))^2 + t*b
% and repeat this process if b*=abs(z3), etc.
% This reduces problem to finding a cut-off index, where
% all coordinates are shrunk up to and including that of
% the cut-off index.  The cut-off index is the smallest
% integer k such that
%    1/k sum(abs(z(1)),...,abs(z(k))) - t/k <= abs(z(k+1))
%

x = y;
[dummy,o] = sort(abs(y),'descend');
z = y(o);
mz = abs(z);

% find cut-off index
cs = cumsum(abs(z(1:length(z)-1)))./(1:length(z)-1)'-t./(1:length(z)-1)';
d = (cs>abs(z(2:length(z))));
if sum(d) == 0
    cut_index = length(y);
else
    cut_index = min(find(d==1));
end

% shrink coordinates 1 to cut_index
zbar = mean(abs(z(1:cut_index)));
if cut_index < length(y)
    x(o(1:cut_index)) = sign(z(1:cut_index))*max(zbar-t/cut_index,abs(z(cut_index+1)));
else
    x(o(1:cut_index)) = sign(z(1:cut_index))*max(zbar-t/cut_index,0);
end

end


